<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PostgresUserRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">product-catalog</a> &gt; <a href="index.source.html" class="el_package">org.idvairaz.repository.impl</a> &gt; <span class="el_source">PostgresUserRepository.java</span></div><h1>PostgresUserRepository.java</h1><pre class="source lang-java linenums">package org.idvairaz.repository.impl;

import org.idvairaz.config.DatabaseConfig;
import org.idvairaz.model.User;
import org.idvairaz.repository.UserRepository;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Реализация репозитория пользователей для работы с PostgreSQL.
 * Обеспечивает сохранение, поиск и управление пользователями в базе данных.
 * Использует JDBC для прямого взаимодействия с PostgreSQL.
 *
 * @author idvavraz
 * @version 1.0
 */
<span class="fc" id="L23">public class PostgresUserRepository implements UserRepository {</span>

    /** Имя схемы базы данных, используемой приложением */
<span class="fc" id="L26">    private final String schema = DatabaseConfig.getSchema();</span>

    /**
     * Сохраняет или обновляет пользователя в базе данных.
     * Для новых пользователей генерирует идентификатор через sequence user_seq.
     * Для существующих пользователей обновляет все поля.
     *
     * @param user пользователь для сохранения или обновления
     * @return сохраненный пользователь
     * @throws RuntimeException если произошла ошибка SQL или пользователь для обновления не найден
     *
     *  Для новых пользователей:
     * 1. Получает следующий ID из sequence user_seq
     * 2. Выполняет INSERT с указанием всех полей
     * 3. Возвращает пользователя без изменения объекта
     *
     *  Для существующих пользователей:
     * 1. Выполняет UPDATE всех полей по username
     * 2. Генерирует исключение если пользователь не найден
     */

    @Override
    public User save(User user) {
<span class="pc bpc" id="L49" title="1 of 4 branches missed.">        boolean isNew = user.getUsername() == null || !existsByUsername(user.getUsername());</span>
        String sql;

<span class="fc" id="L52">        try (Connection conn = DatabaseConfig.getConnection()) {</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">            if (isNew) {</span>
<span class="fc" id="L54">                long newId = getNextIdFromSequence(conn);</span>
<span class="fc" id="L55">                user.setId(newId);</span>

<span class="fc" id="L57">                sql = &quot;INSERT INTO &quot; + schema + &quot;.users (id, username, password, role, is_logged_in) &quot; +</span>
                        &quot;VALUES (?, ?, ?, ?, ?)&quot;;

<span class="fc" id="L60">                try (PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
<span class="fc" id="L61">                    stmt.setLong(1, user.getId());</span>
<span class="fc" id="L62">                    stmt.setString(2, user.getUsername());</span>
<span class="fc" id="L63">                    stmt.setString(3, user.getPassword());</span>
<span class="fc" id="L64">                    stmt.setString(4, user.getRole().name());</span>
<span class="fc" id="L65">                    stmt.setBoolean(5, user.isLoggedIn());</span>

<span class="fc" id="L67">                    stmt.executeUpdate();</span>
<span class="fc" id="L68">                    System.out.println(&quot;Создан пользователь: &quot; + user.getUsername() + &quot; (ID: &quot; + user.getId() + &quot;)&quot;);</span>
<span class="fc" id="L69">                    return user;</span>
                }
            } else {
<span class="fc" id="L72">                Optional&lt;User&gt; existingUser = findByUsername(user.getUsername());</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">                if (existingUser.isEmpty()) {</span>
<span class="nc" id="L74">                    throw new RuntimeException(&quot;Пользователь &quot; + user.getUsername() + &quot; не найден для обновления&quot;);</span>
                }

<span class="fc" id="L77">                sql = &quot;UPDATE &quot; + schema + &quot;.users SET password = ?, role = ?, is_logged_in = ? &quot; +</span>
                        &quot;WHERE username = ?&quot;;

<span class="fc" id="L80">                try (PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
<span class="fc" id="L81">                    stmt.setString(1, user.getPassword());</span>
<span class="fc" id="L82">                    stmt.setString(2, user.getRole().name());</span>
<span class="fc" id="L83">                    stmt.setBoolean(3, user.isLoggedIn());</span>
<span class="fc" id="L84">                    stmt.setString(4, user.getUsername());</span>

<span class="fc" id="L86">                    int affectedRows = stmt.executeUpdate();</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">                    if (affectedRows == 0) {</span>
<span class="nc" id="L88">                        throw new RuntimeException(&quot;Пользователь &quot; + user.getUsername() + &quot; не найден для обновления&quot;);</span>
                    }
<span class="fc" id="L90">                    user.setId(existingUser.get().getId());</span>
<span class="fc" id="L91">                    return user;</span>
                }
            }
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        } catch (SQLException e) {</span>
<span class="nc" id="L95">            throw new RuntimeException(&quot;Ошибка сохранения пользователя '&quot; + user.getUsername() + &quot;'&quot;, e);</span>
        }
    }

    /**
     * Находит пользователя по идентификатору.
     * Поиск выполняется по точному совпадению числового идентификатора.
     *
     * @param id идентификатор пользователя для поиска
     * @return Optional с найденным пользователем, или empty если пользователь не найден
     * @throws RuntimeException если произошла ошибка при выполнении SQL запроса
     */
    @Override
    public Optional&lt;User&gt; findById(Long id) {
<span class="nc" id="L109">        String sql = &quot;SELECT * FROM &quot; + schema + &quot;.users WHERE id = ?&quot;;</span>

<span class="nc" id="L111">        try (Connection conn = DatabaseConfig.getConnection();</span>
<span class="nc" id="L112">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>

<span class="nc" id="L114">            stmt.setLong(1, id);</span>
<span class="nc" id="L115">            ResultSet rs = stmt.executeQuery();</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">            if (rs.next()) {</span>
<span class="nc" id="L118">                return Optional.of(mapResultSetToUser(rs));</span>
            }

<span class="nc bnc" id="L121" title="All 4 branches missed.">        } catch (SQLException e) {</span>
<span class="nc" id="L122">            throw new RuntimeException(&quot;Ошибка поиска пользователя по ID: &quot; + id, e);</span>
<span class="nc" id="L123">        }</span>

<span class="nc" id="L125">        return Optional.empty();</span>
    }

    /**
     * Находит пользователя по имени пользователя.
     * Поиск выполняется по точному совпадению имени (case-sensitive).
     *
     * @param username имя пользователя для поиска
     * @return Optional с найденным пользователем, или empty если пользователь не найден
     * @throws RuntimeException если произошла ошибка при выполнении SQL запроса
     */
    @Override
    public Optional&lt;User&gt; findByUsername(String username) {
<span class="fc" id="L138">        String sql = &quot;SELECT * FROM &quot; + schema + &quot;.users WHERE username = ?&quot;;</span>

<span class="fc" id="L140">        try (Connection conn = DatabaseConfig.getConnection();</span>
<span class="fc" id="L141">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>

<span class="fc" id="L143">            stmt.setString(1, username);</span>
<span class="fc" id="L144">            ResultSet rs = stmt.executeQuery();</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (rs.next()) {</span>
<span class="fc" id="L147">                return Optional.of(mapResultSetToUser(rs));</span>
            }

<span class="pc bpc" id="L150" title="2 of 4 branches missed.">        } catch (SQLException e) {</span>
<span class="nc" id="L151">            throw new RuntimeException(&quot;Ошибка поиска пользователя по имени: &quot; + username, e);</span>
<span class="fc" id="L152">        }</span>

<span class="fc" id="L154">        return Optional.empty();</span>
    }

    /**
     * Возвращает всех пользователей из базы данных.
     * Пользователи возвращаются в алфавитном порядке их имен.
     *
     * @return список всех пользователей, может быть пустым если пользователей нет
     * @throws RuntimeException если произошла ошибка при выполнении SQL запроса
     */
    @Override
    public List&lt;User&gt; findAll() {
<span class="fc" id="L166">        List&lt;User&gt; users = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L167">        String sql = &quot;SELECT * FROM &quot; + schema + &quot;.users ORDER BY username&quot;;</span>

<span class="fc" id="L169">        try (Connection conn = DatabaseConfig.getConnection();</span>
<span class="fc" id="L170">             PreparedStatement stmt = conn.prepareStatement(sql);</span>
<span class="fc" id="L171">             ResultSet rs = stmt.executeQuery()) {</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">            while (rs.next()) {</span>
<span class="fc" id="L174">                users.add(mapResultSetToUser(rs));</span>
            }

<span class="nc" id="L177">        } catch (SQLException e) {</span>
<span class="nc" id="L178">            throw new RuntimeException(&quot;Ошибка получения всех пользователей&quot;, e);</span>
<span class="fc" id="L179">        }</span>

<span class="fc" id="L181">        return users;</span>
    }

    /**
     * Удаляет пользователя по идентификатору.
     * Если пользователь с указанным ID не существует, операция считается успешной
     * и выводится информационное сообщение.
     *
     * @param id идентификатор пользователя для удаления
     * @throws RuntimeException если произошла ошибка при выполнении SQL запроса
     *
     *  Метод не генерирует исключение если пользователь не найден,
     * только выводит сообщение в консоль
     */
    @Override
    public void deleteById(Long id) {
<span class="nc" id="L197">        String sql = &quot;DELETE FROM &quot; + schema + &quot;.users WHERE id = ?&quot;;</span>

<span class="nc" id="L199">        try (Connection conn = DatabaseConfig.getConnection();</span>
<span class="nc" id="L200">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>

<span class="nc" id="L202">            stmt.setLong(1, id);</span>
<span class="nc" id="L203">            int affectedRows = stmt.executeUpdate();</span>

<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (affectedRows == 0) {</span>
<span class="nc" id="L206">                System.out.println(&quot;Пользователь с ID &quot; + id + &quot; не найден для удаления&quot;);</span>
            } else {
<span class="nc" id="L208">                System.out.println(&quot;Пользователь с ID &quot; + id + &quot; удален&quot;);</span>
            }

<span class="nc" id="L211">        } catch (SQLException e) {</span>
<span class="nc" id="L212">            throw new RuntimeException(&quot;Ошибка удаления пользователя по ID: &quot; + id, e);</span>
<span class="nc" id="L213">        }</span>
<span class="nc" id="L214">    }</span>

    /**
     * Удаляет пользователя по имени пользователя.
     * Если пользователь с указанным именем не существует, операция считается успешной
     * и выводится информационное сообщение.
     *
     * @param username имя пользователя для удаления
     * @throws RuntimeException если произошла ошибка при выполнении SQL запроса
     *
     *  Метод не генерирует исключение если пользователь не найден,
     * только выводит сообщение в консоль
     */
    @Override
    public void deleteByUsername(String username) {
<span class="fc" id="L229">        String sql = &quot;DELETE FROM &quot; + schema + &quot;.users WHERE username = ?&quot;;</span>

<span class="fc" id="L231">        try (Connection conn = DatabaseConfig.getConnection();</span>
<span class="fc" id="L232">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>

<span class="fc" id="L234">            stmt.setString(1, username);</span>
<span class="fc" id="L235">            int affectedRows = stmt.executeUpdate();</span>

<span class="pc bpc" id="L237" title="1 of 2 branches missed.">            if (affectedRows == 0) {</span>
<span class="nc" id="L238">                System.out.println(&quot;Пользователь &quot; + username + &quot; не найден для удаления&quot;);</span>
            } else {
<span class="fc" id="L240">                System.out.println(&quot;Пользователь &quot; + username + &quot; удален&quot;);</span>
            }

<span class="nc" id="L243">        } catch (SQLException e) {</span>
<span class="nc" id="L244">            throw new RuntimeException(&quot;Ошибка удаления пользователя: &quot; + username, e);</span>
<span class="fc" id="L245">        }</span>
<span class="fc" id="L246">    }</span>

    /**
     * Проверяет существование пользователя с указанным именем.
     *
     * @param username имя пользователя для проверки
     * @return true если пользователь существует, false в противном случае
     * @throws RuntimeException если произошла ошибка при выполнении SQL запроса
     */
    @Override
    public boolean existsByUsername(String username) {
<span class="fc" id="L257">        String sql = &quot;SELECT COUNT(*) FROM &quot; + schema + &quot;.users WHERE username = ?&quot;;</span>

<span class="fc" id="L259">        try (Connection conn = DatabaseConfig.getConnection();</span>
<span class="fc" id="L260">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>

<span class="fc" id="L262">            stmt.setString(1, username);</span>
<span class="fc" id="L263">            ResultSet rs = stmt.executeQuery();</span>

<span class="pc bpc" id="L265" title="1 of 2 branches missed.">            if (rs.next()) {</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">                return rs.getInt(1) &gt; 0;</span>
            }

<span class="pc bpc" id="L269" title="2 of 4 branches missed.">        } catch (SQLException e) {</span>
<span class="nc" id="L270">            throw new RuntimeException(&quot;Ошибка проверки существования пользователя: &quot; + username, e);</span>
<span class="nc" id="L271">        }</span>

<span class="nc" id="L273">        return false;</span>
    }

    /**
     * Проверяет существование пользователя с указанным идентификатором.
     *
     * @param id идентификатор пользователя для проверки
     * @return true если пользователь существует, false в противном случае
     * @throws RuntimeException если произошла ошибка при выполнении SQL запроса
     */
    public boolean existsById(Long id) {
<span class="nc" id="L284">        String sql = &quot;SELECT COUNT(*) FROM &quot; + schema + &quot;.users WHERE id = ?&quot;;</span>

<span class="nc" id="L286">        try (Connection conn = DatabaseConfig.getConnection();</span>
<span class="nc" id="L287">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>

<span class="nc" id="L289">            stmt.setLong(1, id);</span>
<span class="nc" id="L290">            ResultSet rs = stmt.executeQuery();</span>

<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (rs.next()) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                return rs.getInt(1) &gt; 0;</span>
            }

<span class="nc bnc" id="L296" title="All 4 branches missed.">        } catch (SQLException e) {</span>
<span class="nc" id="L297">            throw new RuntimeException(&quot;Ошибка проверки существования пользователя по ID: &quot; + id, e);</span>
<span class="nc" id="L298">        }</span>

<span class="nc" id="L300">        return false;</span>
    }

    /**
     * Возвращает общее количество пользователей в системе.
     *
     * @return количество пользователей (0 если пользователей нет)
     * @throws RuntimeException если произошла ошибка при выполнении SQL запроса
     */
    @Override
    public int getTotalUsersCount() {
<span class="nc" id="L311">        String sql = &quot;SELECT COUNT(*) FROM &quot; + schema + &quot;.users&quot;;</span>

<span class="nc" id="L313">        try (Connection conn = DatabaseConfig.getConnection();</span>
<span class="nc" id="L314">             PreparedStatement stmt = conn.prepareStatement(sql);</span>
<span class="nc" id="L315">             ResultSet rs = stmt.executeQuery()) {</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (rs.next()) {</span>
<span class="nc" id="L318">                return rs.getInt(1);</span>
            }

<span class="nc bnc" id="L321" title="All 6 branches missed.">        } catch (SQLException e) {</span>
<span class="nc" id="L322">            throw new RuntimeException(&quot;Ошибка получения количества пользователей&quot;, e);</span>
<span class="nc" id="L323">        }</span>

<span class="nc" id="L325">        return 0;</span>
    }

    /**
     * Получает следующий идентификатор из sequence user_seq.
     * Используется для генерации уникальных ID новых пользователей.
     *
     * @param conn активное соединение с базой данных
     * @return следующий уникальный идентификатор из sequence
     * @throws SQLException если произошла ошибка при обращении к sequence
     *
     *  Sequence должна быть создана в той же схеме, что и таблица users
     * @see #save(User)
     */
    private long getNextIdFromSequence(Connection conn) throws SQLException {
<span class="fc" id="L340">        String sequenceSql = &quot;SELECT nextval('&quot; + schema + &quot;.user_seq')&quot;;</span>

<span class="fc" id="L342">        try (PreparedStatement seqStmt = conn.prepareStatement(sequenceSql);</span>
<span class="fc" id="L343">             ResultSet rs = seqStmt.executeQuery()) {</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            if (rs.next()) {</span>
<span class="fc" id="L345">                return rs.getLong(1);</span>
            } else {
<span class="nc" id="L347">                throw new SQLException(&quot;Не удалось получить значение из sequence user_seq&quot;);</span>
            }
        }
    }

    /**
     * Преобразует ResultSet в объект User.
     * Вспомогательный метод для маппинга данных из базы в Java-объект.
     * Предполагает, что ResultSet позиционирован на корректной строке.
     *
     * @param rs ResultSet с данными пользователя, позиционированный на нужной строке
     * @return объект User с данными из ResultSet
     * @throws SQLException если произошла ошибка при чтении данных из ResultSet
     *
     *  Метод не перемещает курсор ResultSet, вызывающий код должен
     * убедиться что rs.next() был вызван и вернул true
     *  Поле id не устанавливается, так как не используется в бизнес-логике User
     */
    private User mapResultSetToUser(ResultSet rs) throws SQLException {
<span class="fc" id="L366">        User user = new User();</span>
<span class="fc" id="L367">        user.setId(rs.getLong(&quot;id&quot;));</span>
<span class="fc" id="L368">        user.setUsername(rs.getString(&quot;username&quot;));</span>
<span class="fc" id="L369">        user.setPassword(rs.getString(&quot;password&quot;));</span>
<span class="fc" id="L370">        user.setRole(User.UserRole.valueOf(rs.getString(&quot;role&quot;)));</span>
<span class="fc" id="L371">        user.setLoggedIn(rs.getBoolean(&quot;is_logged_in&quot;));</span>
<span class="fc" id="L372">        return user;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>